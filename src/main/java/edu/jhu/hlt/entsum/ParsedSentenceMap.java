package edu.jhu.hlt.entsum;

import java.io.BufferedReader;
import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import edu.jhu.hlt.entsum.CluewebLinkedPreprocess.EntityMentionRanker.ScoredPassage;
import edu.jhu.hlt.tutils.FileUtil;
import edu.jhu.hlt.tutils.Log;
import edu.jhu.hlt.tutils.MultiAlphabet;

/**
 * Stores and retrieves parses ({@link DepNode} arrays) based on a sentence hash.
 * @see CluewebLinkedSentence#hashHex()
 * 
 * @deprecated and anything which uses this is also deprecated.
 * Should never use hashmap containing sentences, stick to O(1) memory/streaming.
 * @see DistSupSetup for new method which puts data in place.
 */
public class ParsedSentenceMap implements Serializable {
  private static final long serialVersionUID = 6679267677753088077L;

  /**
   * All sentences within a given cluster, like rare4.
   * Keys are hashes created by {@link CluewebLinkedSentence#hash()}
   */
  private Map<UUID, DepNode[]> parsedSentences;
  private MultiAlphabet alph;
  
  public ParsedSentenceMap(File hashes, File conll, MultiAlphabet alph) throws Exception {
    this.alph = alph;
    this.parsedSentences = new HashMap<>();
    Log.info("hashes=" + hashes.getPath() + " conll=" + conll.getPath());
    try (DepNode.ConllxFileReader iter = new DepNode.ConllxFileReader(conll, alph);
        BufferedReader hashReader = FileUtil.getReader(hashes)) {
      while (iter.hasNext()) {
        DepNode[] sentence = iter.next();
        String hash = hashReader.readLine();
        UUID h = convert(hash);
        assert hash.equals(h.toString().replaceAll("-", ""));
        Object old = parsedSentences.put(h, sentence);
        assert old == null;
      }
      assert hashReader.readLine() == null;
    }
    Log.info("done, read " + parsedSentences.size() + " hashes/parses");
  }
  
  public List<ScoredPassage> getAllParses(List<CluewebLinkedSentence> sentences) {
    List<ScoredPassage> out = new ArrayList<>(sentences.size());
    for (CluewebLinkedSentence s : sentences) {
      DepNode[] p = getParse(s.hashHex());
      assert p != null;
      out.add(new ScoredPassage(s, p));
    }
    return out;
  }
  
  public MultiAlphabet getAlph() {
    return alph;
  }
  
  /**
   * @param hash is a length-32 hex string generated by {@link CluewebLinkedSentence#hashHex()}
   */
  public DepNode[] getParse(String hash) {
    return getParse(convert(hash));
  }
  
  /**
   * @param hash is generated by {@link CluewebLinkedSentence#hashUuid()}
   */
  public DepNode[] getParse(UUID hash) {
    return parsedSentences.get(hash);
  }
  
  public int numParses() {
    return parsedSentences.size();
  }
  
  public static UUID convert(String hash) {
    if (hash.length() != 32)
      throw new IllegalArgumentException("hash=" + hash);
    long hi = Long.parseUnsignedLong(hash.substring(0, 16), 16);
    long lo = Long.parseUnsignedLong(hash.substring(16), 16);
    return new UUID(hi, lo);
  }
}