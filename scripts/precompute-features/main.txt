
# How to run all the scripts in this directory by hand.
# By hand because it needs to be asyncronous (qsub takes a while and doesn't block)


############################################################################################
### CREATE MANY SHARDS OF FEATURES

# Start redis parse servers.
# These slightly an accident of history with some meh reasons:
# 1) I didn't originally serialize the parses with the Propbank data
# 2) I wanted a way to cache parses across machines
# 3) I can fit all of the FNParses in memory, but not with the parses as well
#qsub -N parse-fPreComp ./scripts/propbank-train-redis-parse-server.sh
#qsub -N parse-fPreComp ./scripts/propbank-train-redis-parse-server.sh
#qsub -N parse-fPreComp ./scripts/propbank-train-redis-parse-server.sh
#qsub -N parse-fPreComp ./scripts/propbank-train-redis-parse-server.sh
# Now look up the machines these were dispatched to and copy those namaes into the array below.


DATASET=framenet
#WORKING_DIR=experiments/precompute-features/propbank/sep14a/raw-shards
#WORKING_DIR=/export/projects/twolfe/fnparse-output/experiments/precompute-features/propbank/sep14b/raw-shards
WORKING_DIR=/export/projects/twolfe/fnparse-output/experiments/precompute-features/framenet/sep29a/raw-shards
JAR=target/fnparse-1.0.6-SNAPSHOT-jar-with-dependencies.jar
NUM_SHARDS=100
PARSE_REDIS_SERVERS=(r5n23 r5n32 r6n03 r6n08)

mkdir -p $WORKING_DIR/sge-logs

echo "copyinig jar to a safe place..."
JAR_STABLE=$WORKING_DIR/fnparse.jar
echo "    $JAR"
echo "==> $JAR_STABLE"
cp $JAR $JAR_STABLE

# TODO move `cp $JAR $JAR_STABLE` up to this script
echo "starting at `date`" >>$WORKING_DIR/commands.txt
for i in `seq $NUM_SHARDS | awk '{print $1 - 1}'`; do
  WD=$WORKING_DIR/job-$i-of-$NUM_SHARDS
  J=`echo $i | awk '{print $1 % 4}'`
  PS=${PARSE_REDIS_SERVERS[$J]}
  echo "dispatching to $PS"
  mkdir -p $WD
  COMMAND="qsub -N fPreComp-$i-$NUM_SHARDS \
    -o $WORKING_DIR/sge-logs \
    scripts/precompute-features/extract-one-shard.sh \
      $WD \
      $JAR_STABLE \
      $i \
      $NUM_SHARDS \
      $PS \
      $DATASET"
   echo $COMMAND >>$WORKING_DIR/commands.txt
   eval $COMMAND
done


############################################################################################
### MERGE MANY SHARDS INTO A COHERENT ALPHABET
WORKING_DIR=/export/projects/twolfe/fnparse-output/experiments/precompute-features/framenet/sep29a
python -u scripts/precompute-features/bialph-merge-pipeline.py \
  $WORKING_DIR \
  $NUM_SHARDS \
  | tee /tmp/merge-job-launch-log.txt


############################################################################################
### CREATE TEMPLATE FILTERS
# e.g. "only have a feature fire if it is in the top K most frequent by this template"
# or "only have this feature fire if is has fired at least K other times in the corpus"
# These features will be put at the end of every line in the feature files and a new
# alphabet will be writte out including them.

# A) Compute the feature frequencies
WD=parent/of/features
BIALPH_BEFORE_FILTERS=bar
mkdir $WD/feature-counts
qsub -b y -j y -o foo -cwd -l 'mem_free=16G,num_proc=1,h_rt=12:00:00' \
  java jar \
    -Dbialph=$BIALPH_BEFORE_FILTERS \
    -Doutput=$WD/feature-counts/all.txt.gz \
    -DfeaturesParent=$WD/features \
    edu.jhu.hlt.fnparse.features.precompute.FeatureCounts
qsub -b y -j y -o foo -cwd -l 'mem_free=16G,num_proc=1,h_rt=12:00:00' \
  java jar \
    -Dbialph=$BIALPH_BEFORE_FILTERS \
    -Doutput=$WD/feature-counts/one-tenth.txt.gz \
    -DfeaturesGlob="glob:**/shard*9.txt.gz" \
    -DfeaturesParent=$WD/features \
    edu.jhu.hlt.fnparse.features.precompute.FeatureCounts
qsub -b y -j y -o foo -cwd -l 'mem_free=16G,num_proc=1,h_rt=12:00:00' \
  java jar \
    -Dbialph=$BIALPH_BEFORE_FILTERS \
    -Doutput=$WD/feature-counts/one-hundredth.txt.gz \
    -DfeaturesGlob="glob:**/shard*99.txt.gz" \
    -DfeaturesParent=$WD/features \
    edu.jhu.hlt.fnparse.features.precompute.FeatureCounts

# B) Generate the filtered features based on the frequencies
#   (if i try to do ~60G => +filters:~8x => 250G with one process... it is going to take a while...)
mkdir $WD/features-filtered
BIALPH_AFTER_FILTERS=$WD/features-filtered/alphabet.txt.gz
COUNT_FILE=$WD/feature-counts/one-hundredth.txt.gz
# Takes shard 0 and builds output bialph
qsub -b y -j y -o foo -cwd -l 'mem_free=16G,num_proc=1,h_rt=12:00:00' \
  java jar \
    -DcountFile=$COUNT_FILE \
    -DoutputBialph=$BIALPH_AFTER_FILTERS \
    -Dbialph=$BIALPH_BEFORE_FILTERS \
    -DoutputFeatureFileDir=$WD/features-filtered \
    -DfeaturesGlob="shard:**/shard*0.txt.gz" \
    -DfeaturesParent=$WD/features \
    edu.jhu.hlt.fnparse.features.precompute.TemplateTransformer
for SHARD in `seq 9`; do    # takes shards 1..9
  qsub -b y -j y -o foo -cwd -l 'mem_free=16G,num_proc=1,h_rt=12:00:00' \
    java jar \
      -DcountFile=$COUNT_FILE \
      -Dbialph=$BIALPH_BEFORE_FILTERS \
      -DoutputFeatureFileDir=$WD/features-filtered \
      -DfeaturesGlob="glob:**/shard*${SHARD}.txt.gz" \
      -DfeaturesParent=$WD/features \
      edu.jhu.hlt.fnparse.features.precompute.TemplateTransformer
done



############################################################################################
### COMPUTE INFORMATION GAIN
#WD=/export/projects/twolfe/fnparse-output/experiments/precompute-features/propbank/sep14b
WD=/export/projects/twolfe/fnparse-output/experiments/precompute-features/framenet/sep29a

# 0) Find the sentence ids of the test set and don't use these for computing information gain
TEST_SET_SENT_IDS="$WD/test-set-sentence-ids.txt"
mvn exec:java \
  -Dexec.mainClass=edu.jhu.hlt.fnparse.features.precompute.DumpSentenceIds \
  -Ddata.ontonotes5=data/ontonotes-release-5.0/LDC2013T19/data/files/data/english/annotations \
  -Ddata.propbank.conll=../conll-formatted-ontonotes-5.0/conll-formatted-ontonotes-5.0/data \
  -Ddata.propbank.frames=data/ontonotes-release-5.0-fixed-frames/frames \
  -Ddata=$DATASET \
  -Dpart=test \
  -Doutput=$TEST_SET_SENT_IDS

# 1) For each template
mkdir -p $WD/ig/templates
mkdir -p $WD/ig/templates/sge-logs

JAR=target/fnparse-1.0.6-SNAPSHOT-jar-with-dependencies.jar
JAR_STABLE=$WD/ig/templates/fnparse.jar
echo "copying the jar to a safe place..."
echo "    $JAR"
echo "==> $JAR_STABLE"
cp $JAR $JAR_STABLE

#TEMPLATE_IG_FILE=$WD/ig/template-ig.txt
#java -Xmx19G -cp $JAR \
#  -DfeaturesParent=$WD/coherent-shards/features/ \
#  -DfeaturesGlob="glob:**/*" \
#  -DtopK=1000 \
#  -DoutputFeatures=$TEMPLATE_IG_FILE \
#  edu.jhu.hlt.fnparse.features.precompute.InformationGain

# Do a 1/10 estimate of 1/10 of the data and average the answers (should take 1/10th the time but be approximate)
N=10
mkdir -p $WD/ig/templates/split-$N-filter10
for i in `seq $N | awk '{print $1-1}'`; do
  qsub -N split$N-$i-filter10-ig-template \
    -o $WD/ig/templates/sge-logs \
    scripts/precompute-features/compute-ig.sh \
      $WD/coherent-shards/features \
      "glob:**/*1${i}.txt.gz" \
      $WD/ig/templates/split-$N-filter10/shard-${i}.txt \
      $JAR_STABLE \
      $TEST_SET_SENT_IDS
done

# Do a 1/10 estimate and average the answers (should take 1/10th the time but be approximate)
N=10
mkdir -p $WD/ig/templates/split-$N
for i in `seq $N | awk '{print $1-1}'`; do
  qsub -N split$N-$i-ig-template \
    -o $WD/ig/templates/sge-logs \
    scripts/precompute-features/compute-ig.sh \
      $WD/coherent-shards/features \
      "glob:**/*${i}.txt.gz" \
      $WD/ig/templates/split-$N/shard-${i}.txt \
      $JAR_STABLE \
      $TEST_SET_SENT_IDS
done

# Do a full/proper estimate
qsub -N full-ig-template \
  -o $WD/ig/templates/sge-logs \
  scripts/precompute-features/compute-ig.sh \
    $WD/coherent-shards/features \
    "glob:**/*" \
    $WD/ig/templates/full-ig.txt \
    $JAR_STABLE \
    $TEST_SET_SENT_IDS


### After those jobs finish, average things
python scripts/precompute-features/average-ig.py \
  $WD/ig/templates/split-$N/shard-* \
  >$WD/ig/templates/split-$N/average.txt


# 2) For prodcuts of templates, filtered by top K products ranked by product of template IG
# NOTE: The more shards the more products we compute on
#TEMPLATE_IG_FILE=$WD/ig/templates/split-$N/average.txt
TEMPLATE_IG_FILE=$WD/ig/templates/full-ig.txt
PROD_IG_WD=$WD/ig/products
mkdir -p $PROD_IG_WD/ig-files
mkdir -p $PROD_IG_WD/sge-logs
cp target/fnparse-1.0.6-SNAPSHOT-jar-with-dependencies.jar $PROD_IG_WD/fnparse.jar
NUM_SHARDS=300
FEATS_PER_SHARD=300
for i in `seq $NUM_SHARDS | awk '{print $1 - 1}'`; do
  qsub -N prod-ig-$i -o $PROD_IG_WD/sge-logs \
    ./scripts/precompute-features/compute-ig-products.sh \
      $i \
      $NUM_SHARDS \
      $FEATS_PER_SHARD \
      $TEMPLATE_IG_FILE \
      $WD/coherent-shards/features \
      "glob:**/*" \
      $WD/coherent-shards/alphabet.txt.gz \
      $TEST_SET_SENT_IDS \
      $PROD_IG_WD/ig-files/shard-${i}-of-${NUM_SHARDS}.txt \
      $PROD_IG_WD/fnparse.jar
done




############################################################################################
# TODO Embed features?
# Just run word2vec on my feature files (after filtering by top K templates by MI maybe)?
# Pretty sure the embeddings will not be linear with the weights,
#   will want some type of RBF kernel perceptron (average alpha*K(x,x') over all features for a given instance as decision rule).




############################################################################################
### RUN THE ACTUAL EXPERIMENTS

# 1) see Makefile in scripts/having-a-laugh (build feature sets based on product IG + dedup)
# 2) launch experiments with scripts/precompute-features/train-all.sh

WD=/export/projects/twolfe/fnparse-output/experiments/for-sept-tacl/propbank
IS_PROPBANK="true"
DEFAULT_DIM=640
#WD=/export/projects/twolfe/fnparse-output/experiments/for-sept-tacl/framenet
#IS_PROPBANK="false"
#DEFAULT_DIM=320

DEFAULT_ORACLE="RAND_MIN"
DEFAULT_BEAM=1

# Oracle mode
BEAM_SIZE=$DEFAULT_BEAM
ORACLE_MODE="#"
DIM=$DEFAULT_DIM
FORCE_LEFT_RIGHT="false"
PERCEPTRON="false"
./scripts/precompute-features/train-all.sh \
  $WD/sweep-oracle \
  $IS_PROPBANK \
  $DIM \
  $ORACLE_MODE \
  $BEAM_SIZE \
  $FORCE_LEFT_RIGHT \
  $PERCEPTRON \
  "N"

# Dimension / feature set
BEAM_SIZE=$DEFAULT_BEAM
ORACLE_MODE=$DEFAULT_ORACLE
DIM="#"
FORCE_LEFT_RIGHT="false"
PERCEPTRON="false"
./scripts/precompute-features/train-all.sh \
  $WD/sweep-dim \
  $IS_PROPBANK \
  $DIM \
  $ORACLE_MODE \
  $BEAM_SIZE \
  $FORCE_LEFT_RIGHT \
  $PERCEPTRON \
  "D"

# Force left right
# and perceptron
BEAM_SIZE=$DEFAULT_BEAM
ORACLE_MODE=$DEFAULT_ORACLE
DIM=$DEFAULT_DIM
FORCE_LEFT_RIGHT="#"
PERCEPTRON="#"
./scripts/precompute-features/train-all.sh \
  $WD/sweep-beam \
  $IS_PROPBANK \
  $DIM \
  $ORACLE_MODE \
  $BEAM_SIZE \
  $FORCE_LEFT_RIGHT \
  $PERCEPTRON \
  "L"

# Beam size
BEAM_SIZE="#"
ORACLE_MODE=$DEFAULT_ORACLE
DIM=$DEFAULT_DIM
FORCE_LEFT_RIGHT="false"
PERCEPTRON="false"
./scripts/precompute-features/train-all.sh \
  $WD/sweep-beam \
  $IS_PROPBANK \
  $DIM \
  $ORACLE_MODE \
  $BEAM_SIZE \
  $FORCE_LEFT_RIGHT \
  $PERCEPTRON \
  "B"

# vim: set syntax=sh
